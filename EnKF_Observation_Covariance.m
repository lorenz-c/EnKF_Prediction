function [C_big, errs] = EnKF_Observation_Covariance(settings)
% This function computes the covariance matrix of observations, which will
% be later used to draw some random noise for pertubing the observations.


% Generate a time-reference-vector which covers the assimilation period                      
% T_assim = dtevec(settings.assim.sdte, settings.assim.edte);




%% PRECIPITATION SECTION
if strcmp(settings.obscov.errs_P.method, 'ensemble') 
    % Load P-data for the background matrices
    P_back = EnKF_Prepare_Data(settings.obscov.data_back, ...
                       'prec', ...
                       'prec', ...
                       settings.id_var, ...
                       settings.region_ids, ...
                       settings.obscov.sdte_back, ...
                       settings.obscov.edte_back, ...
                       settings.obscov.remsc_back, ...
                       settings.obscov.flt_back, ...
                       false);
    % Load actual P-data for re-scaling the background matrices               
    P_scle = EnKF_Prepare_Data(settings.obscov.data_scle, ...
                       'prec', ...
                       'prec', ...
                       settings.id_var, ...
                       settings.region_ids, ...
                       settings.obscov.sdte_scle, ...
                       settings.obscov.edte_scle, ...
                       settings.obscov.remsc_scle, ...
                       settings.obscov.flt_scle, ...
                       false);
                   
    % Compute the ensemble range in every time-step
    rnge_P  = 1/2*(max(P_back, [], 3) - min(P_back, [], 3));
    
    % Compute the covariance matrix of the ranges 
    Sig_P   = nancov_matrix(rnge_P, rnge_P);   
    
    % Transform the cov. matrix into a corr. matrix
    Rho_P   = cov2corr(Sig_P); 
              
    % Loop over twelve months
    for i = 1:12
        % Compute the standard deviation of every month
        std_ssnl_P   = nanstd(P_scle(i:12:end, :, :), 1);
        % Compute the mean over the ensemble
        std_ssnl_P   = nanmean(std_ssnl_P, 3);
        % Re-arrange the averaged stds in a diagonal matrix
        std_ssnl_P   = diag(std_ssnl_P);
        % Re-scale the background correlation matrices with the new
        % standard deviations
        C_P(:, :, i) = std_ssnl_P  * Rho_P  * std_ssnl_P;
    end  
    
    % Replicate the monthly C_P-matrices to cover the whole assimilation
    % period
    C_P  = repmat(C_P, 1, 1, settings.nr_yrs);
    
elseif strcmp(settings.obscov.errs_P.method, 'data')
    % Load an ancillary time-series with errors
    P_in = EnKF_Prepare_Data(settings.obscov.errs_P.data, ...
                    [], ...
                    settings.obscov.errs_P.varnme, ...
                    settings.id_var, ...
                    settings.region_ids, ...
                    settings.assim.sdte, ...
                    settings.assim.edte, ...
                    settings.obscov.errs_P.remsc, ...
                    settings.obscov.errs_P.filter, ...
                    false);
    
    % Re-arrange the errors in diagonal matrices for each time-step
    for i = 1:settings.nts
        C_P(:, :, i) = diag(P_in(i, :));
    end                         
                
elseif strcmp(settings.obscov.errs_P.method, 'percentage')
    % Load an ancillary time-series for deriving the percentage errors           
    P_in = EnKF_Prepare_Data(settings.obscov.errs_P.data, ...
                    [], ...
                    settings.obscov.errs_P.varnme, ...
                    settings.id_var, ...
                    settings.region_ids, ...
                    settings.assim.sdte, ...
                    settings.assim.edte, ...
                    settings.obscov.errs_P.remsc, ...
                    settings.obscov.errs_P.filter, ...
                    false);
                   
                   
    % Multiply the errors with a value from the settings-structure
    P_errs = (P_in*settings.obscov.errs_P.value).^2;          
    
    % Re-arrange the scaled values in diagonal matrices for each time-step
    for i = 1:settings.nts
        C_P(:, :, i) = diag(P_errs(i, :));
    end
    
elseif strcmp(settings.obscov.errs_P.method, 'constant') 
    if length(settings.obscov.errs_P.value) == 1
        P_errs = ones(length(settings.region_ids), 1) * ...
                                              settings.obscov.errs_P.value;
    else
        P_errs = settings.obscov.errs_P.value;
    end
    
    for i = 1:settings.nts
        C_P(:, :, i) = diag(P_errs);
    end
end


%% EVAPOTRANSPIRATION SECTION
if strcmp(settings.obscov.errs_E.method, 'ensemble')               
    
    E_back = EnKF_Prepare_Data(settings.obscov.data_back, ...
                      'evap', ...
                      'evap', ...
                      settings.id_var, ...
                      settings.region_ids, ...
                      settings.obscov.sdte_back, ...
                      settings.obscov.edte_back, ...
                      settings.obscov.remsc_back, ...
                      settings.obscov.flt_back, ...
                      false);
                   
    E_scle = EnKF_Prepare_Data(settings.obscov.data_scle, ...
                      'evap', ...
                      'evap', ...
                      settings.id_var, ...
                      settings.region_ids, ...
                      settings.obscov.sdte_scle, ...
                      settings.obscov.edte_scle, ...
                      settings.obscov.remsc_scle, ...
                      settings.obscov.flt_scle, ...
                      false);
    
    % Compute the ensemble range in every time-step
    rnge_E  = 1/2*(max(E_back, [], 3) - min(E_back, [], 3));
    
    % Compute the covariance matrix of the ranges 
    Sig_E   = nancov_matrix(rnge_E, rnge_E);  
    
    % Transform the cov. matrix into a corr. matrix
    Rho_E   = cov2corr(Sig_E); 
    
    for i = 1:12
        % Compute the standard deviation of every month
        std_ssnl_E   = nanstd(E_scle(i:12:end, :, :), 1);
        % Compute the mean over the ensemble
        std_ssnl_E   = nanmean(std_ssnl_E, 3);
        % Re-arrange the averaged stds in a diagonal matrix
        std_ssnl_E   = diag(std_ssnl_E);
        % Re-scale the background correlation matrices with the new
        % standard deviations
        C_E(:, :, i) = std_ssnl_E  * Rho_E  * std_ssnl_E;
    end      
    
    % Replicate the monthly C_P-matrices to cover the whole assimilation
    % period
    C_E  = repmat(C_E, 1, 1, settings.nr_yrs);

elseif strcmp(settings.obscov.errs_E.method, 'data')
    % Load an ancillary time-series for deriving the percentage errors
    E_in = EnKF_Prepare_Data(settings.obscov.errs_E.data, ...
                    [], ...
                    settings.obscov.errs_E.varnme, ...
                    settings.id_var, ...
                    settings.region_ids, ...
                    settings.assim.sdte, ...
                    settings.assim.edte, ...
                    settings.obscov.errs_E.remsc, ...
                    settings.obscov.errs_E.filter, ...
                    false);
                
    for i = 1:settings.nts
        C_E(:, :, i) = diag(E_in(i, :));
    end           
    
elseif strcmp(settings.obscov.errs_E.method, 'percentage')
    % Load an ancillary time-series for deriving the percentage errors
    E_in = EnKF_Prepare_Data(settings.obscov.errs_E.data, ...
                    [], ...
                    settings.obscov.errs_E.varnme, ...
                    settings.id_var, ...
                    settings.region_ids, ...
                    settings.assim.sdte, ...
                    settings.assim.edte, ...
                    settings.obscov.errs_E.remsc, ...
                    settings.obscov.errs_E.filter, ...
                    false);
                
    % Multiply the errors with a value from the settings-structure                    
    E_errs = (E_in*settings.obscov.errs_E.value).^2;          
    
    % Re-arrange the scaled values in diagonal matrices for each time-step
    for i = 1:settings.nts
        C_E(:, :, i) = diag(E_errs(i, :));
    end
    
elseif strcmp(settings.obscov.errs_E.method, 'constant') 
    if length(settings.obscov.errs_E.value) == 1
        E_errs = ones(length(settings.region_ids), 1) * ...
                                              settings.obscov.errs_E.value;
    else
        E_errs = settings.obscov.errs_E.value;
    end
    
    for i = 1:settings.nts
        C_E(:, :, i) = diag(E_errs);
    end
end


%% RUNOFF SECTION
if strcmp(settings.obscov.errs_R.method, 'ensemble')       
    
    R_back = EnKF_Prepare_Data(settings.obscov.data_back, ...
                      'runoff', ...
                      'runoff', ...
                      settings.id_var, ...
                      settings.region_ids, ...
                      settings.obscov.sdte_back, ...
                      settings.obscov.edte_back, ...
                      settings.obscov.remsc_back, ...
                      settings.obscov.flt_back, ...
                      false);
                   
    R_scle = EnKF_Prepare_Data(settings.obscov.data_scle, ...
                      'runoff', ...
                      'runoff', ...
                      settings.id_var, ...
                      settings.region_ids, ...
                      settings.obscov.sdte_scle, ...
                      settings.obscov.edte_scle, ...
                      settings.obscov.remsc_scle, ...
                      settings.obscov.flt_scle, ...
                      false);
                  
                  
    % Compute the ensemble range in every time-step
    rnge_R  = 1/2*(max(R_back, [], 3) - min(R_back, [], 3));
    
    % Compute the covariance matrix of the ranges 
    Sig_R   = nancov_matrix(rnge_R, rnge_R);  
    
    % Transform the cov. matrix into a corr. matrix
    Rho_R   = cov2corr(Sig_R); 
    
    for i = 1:12
        % Compute the standard deviation of every month
        std_ssnl_R   = nanstd(R_scle(i:12:end, :, :), 1);
        % Compute the mean over the ensemble
        std_ssnl_R   = nanmean(std_ssnl_R, 3);
        % Re-arrange the averaged stds in a diagonal matrix
        std_ssnl_R   = diag(std_ssnl_R);
        % Re-scale the background correlation matrices with the new
        % standard deviations
        C_R(:, :, i) = std_ssnl_R  * Rho_R  * std_ssnl_R;
    end       
    
    % Replicate the monthly C_P-matrices to cover the whole assimilation
    % period
    C_R  = repmat(C_R, 1, 1, settings.nr_yrs);

elseif strcmp(settings.obscov.errs_R.method, 'data')
    % Load an ancillary time-series for deriving the percentage errors
    R_in = EnKF_Prepare_Data(settings.obscov.errs_R.data, ...
                    [], ...
                    settings.obscov.errs_R.varnme, ...
                    settings.id_var, ...
                    settings.region_ids, ...
                    settings.assim.sdte, ...
                    settings.assim.edte, ...
                    settings.obscov.errs_R.remsc, ...
                    settings.obscov.errs_R.filter, ...
                    false);
                
    for i = 1:settings.nts
        C_R(:, :, i) = diag(R_in(i, :));
    end  
    
    
elseif strcmp(settings.obscov.errs_R.method, 'percentage')
    % Load an ancillary time-series for deriving the percentage errors
    R_in = EnKF_Prepare_Data(settings.obscov.errs_R.data, ...
                    [], ...
                    settings.obscov.errs_R.varnme, ...
                    settings.id_var, ...
                    settings.region_ids, ...
                    settings.assim.sdte, ...
                    settings.assim.edte, ...
                    settings.obscov.errs_R.remsc, ...
                    settings.obscov.errs_R.filter, ...
                    false);
                
    % Multiply the errors with a value from the settings-structure            
    R_errs = (R_in*settings.obscov.errs_R.value).^2;  

    % Re-arrange the scaled values in diagonal matrices for each time-step
    for i = 1:settings.nts
        C_R(:, :, i) = diag(R_errs(i, :));
    end
    
elseif strcmp(settings.obscov.errs_R.method, 'constant')
    
    if length(settings.obscov.errs_R.value) == 1
        R_errs = ones(length(settings.region_ids), 1) * ...
                                              settings.obscov.errs_R.value;
    else
        R_errs = settings.obscov.errs_R.value;
    end
    
    for i = 1:settings.nts
        C_R(:, :, i) = diag(R_errs);
    end
    
end

%% TWSC SECTION
if strcmp(settings.obscov.errs_DM.method, 'ensemble')  
    
    DM_back = EnKF_Prepare_Data(settings.obscov.data_back, ...
                      'twsc', ...
                      'twsc', ...
                      settings.id_var, ...
                      settings.region_ids, ...
                      settings.obscov.sdte_back, ...
                      settings.obscov.edte_back, ...
                      settings.obscov.remsc_back, ...
                      settings.obscov.flt_back, ...
                      false);
                   
    DM_scle = EnKF_Prepare_Data(settings.obscov.data_scle, ...
                      'twsc', ...
                      'evap', ...
                      settings.id_var, ...
                      settings.region_ids, ...
                      settings.obscov.sdte_scle, ...
                      settings.obscov.edte_scle, ...
                      settings.obscov.remsc_scle, ...
                      settings.obscov.flt_scle, ...
                      false);
                  
    % Compute the ensemble range in every time-step
    rnge_DM  = 1/2*(max(DM_back, [], 3) - min(DM_back, [], 3));
    
    % Compute the covariance matrix of the ranges 
    Sig_DM   = nancov_matrix(rnge_DM, rnge_DM);  
    
    % Transform the cov. matrix into a corr. matrix
    Rho_DM   = cov2corr(Sig_DM); 
    
    for i = 1:12
        % Compute the standard deviation of every month
        std_ssnl_DM   = nanstd(DM_scle(i:12:end, :, :), 1);
        % Compute the mean over the ensemble
        std_ssnl_DM   = nanmean(std_ssnl_DM, 3);
        % Re-arrange the averaged stds in a diagonal matrix
        std_ssnl_DM  = diag(std_ssnl_DM);
        % Re-scale the background correlation matrices with the new
        % standard deviations
        C_DM(:, :, i) = std_ssnl_DM  * Rho_DM  * std_ssnl_DM;
    end     
    
    % Replicate the monthly C_P-matrices to cover the whole assimilation
    % period
    C_DM  = repmat(C_DM, 1, 1, settings.nr_yrs);

elseif strcmp(settings.obscov.errs_DM.method, 'data')
    % Load an ancillary time-series for deriving the percentage errors
    DM_in = EnKF_Prepare_Data(settings.obscov.errs_DM.data, ...
                    [], ...
                    settings.obscov.errs_DM.varnme, ...
                    settings.id_var, ...
                    settings.region_ids, ...
                    settings.assim.sdte, ...
                    settings.assim.edte, ...
                    settings.obscov.errs_DM.remsc, ...
                    settings.obscov.errs_DM.filter, ...
                    false);
                
    for i = 1:settings.nts
        C_DM(:, :, i) = diag(DM_in(i, :));
    end  
    
elseif strcmp(settings.obscov.errs_DM.method, 'percentage')
    % Load an ancillary time-series for deriving the percentage errors
    DM_in = EnKF_Prepare_Data(settings.obscov.errs_DM.data, ...
                    [], ...
                    settings.obscov.errs_DM.varnme, ...
                    settings.id_var, ...
                    settings.region_ids, ...
                    settings.assim.sdte, ...
                    settings.assim.edte, ...
                    settings.obscov.errs_DM.remsc, ...
                    settings.obscov.errs_DM.filter, ...
                    false);
                
    % Multiply the errors with a value from the settings-structure              
    DM_errs = (DM_in*settings.obscov.errs_DM.value).^2;   
    
    % Re-arrange the scaled values in diagonal matrices for each time-step
    for i = 1:settings.nts
        C_DM(:, :, i) = diag(DM_errs(i, :));
    end
    
elseif strcmp(settings.obscov.errs_DM.method, 'constant') 
    if length(settings.obscov.errs_DM.value) == 1
        DM_errs = ones(length(settings.region_ids), 1) * ...
                                              settings.obscov.errs_DM.value;
    else
        DM_errs = settings.obscov.errs_DM.value;
    end
    
    for i = 1:settings.nts
        C_DM(:, :, i) = diag(DM_errs);
    end
    
    
end


% Create dummy matrices
O = zeros(length(settings.region_ids), length(settings.region_ids), settings.nts);
I = repmat(eye(length(settings.region_ids), length(settings.region_ids)), ...
    1, 1, settings.nts);

C_big = [C_P O   O   O    ;
         O   C_E O   O    ;
         O   O   C_R O    ;
         O   O   O   C_DM];


     
     
     
     
     
%% SECTION FOR ADDITIONAL DATA
if ~isempty(settings.obs.p_alt)
    if isfield(settings.obscov, 'p_alt_errs')
        if strcmp(settings.obscov.p_alt_errs.method, 'data')
            P_in = EnKF_Prepare_Data(settings.obscov.p_alt_errs.data, ...
                    [], ...
                    settings.obscov.p_alt_errs.varnme, ...
                    settings.id_var, ...
                    settings.region_ids, ...
                    settings.assim.sdte, ...
                    settings.assim.edte, ...
                    settings.obscov.p_alt_errs.remsc, ...
                    settings.obscov.p_alt_errs.filter, ...
                    false);
                

                
                
            for i = 1:settings.nts
                C_P_alt(:, :, i) = diag(P_in(i, :));
            end  
        
        elseif strcmp(settings.obscov.p_alt_errs.method, 'percentage')
            % Load an ancillary time-series for deriving the percentage errors
            P_in = EnKF_Prepare_Data(settings.obscov.p_alt_errs.data, ...
                    [], ...
                    settings.obscov.p_alt_errs.varnme, ...
                    settings.id_var, ...
                    settings.region_ids, ...
                    settings.assim.sdte, ...
                    settings.assim.edte, ...
                    settings.obscov.p_alt_errs.remsc, ...
                    settings.obscov.p_alt_errs.filter, ...
                    false);
                
            % Multiply the errors with a value from the settings-structure       
            P_errs = (P_in*settings.obscov.p_alt_errs.value).^2;          
    
            % Re-arrange the scaled values in diagonal matrices for each time-step
            for i = 1:settings.nts
                C_P_alt(:, :, i) = diag(P_errs(i, :));
            end
    
        elseif strcmp(settings.obscov.p_alt_errs.method, 'constant') 
            if length(settings.obscov.p_alt_errs.value) == 1
                P_errs = ones(length(settings.region_ids), 1) * ...
                                          settings.obscov.p_alt_errs.value;
            else
                P_errs = settings.obscov.p_alt_errs.value;
            end
    
            for i = 1:settings.nts
                C_P_alt(:, :, i) = diag(P_errs);
            end
            
        end
        
        C_big = [C_big [O; O; O; O]; ...
                 O O O O C_P_alt];
        
    else
        error('Must provide errors for P_alt')
    end   
end

if ~isempty(settings.obs.e_alt)
    if isfield(settings.obscov, 'e_alt_errs')
        if strcmp(settings.obscov.e_alt_errs.method, 'data')
            E_in = EnKF_Prepare_Data(settings.obscov.e_alt_errs.data, ...
                    [], ...
                    settings.obscov.e_alt_errs.varnme, ...
                    settings.id_var, ...
                    settings.region_ids, ...
                    settings.assim.sdte, ...
                    settings.assim.edte, ...
                    settings.obscov.e_alt_errs.remsc, ...
                    settings.obscov.e_alt_errs.filter, ...
                    false);
                            
            for i = 1:settings.nts
                C_E_alt(:, :, i) = diag(E_in(i, :));
            end  
        
        elseif strcmp(settings.obscov.e_alt_errs.method, 'percentage')
            % Load an ancillary time-series for deriving the percentage errors
            E_in = EnKF_Prepare_Data(settings.obscov.e_alt_errs.data, ...
                    [], ...
                    settings.obscov.e_alt_errs.varnme, ...
                    settings.id_var, ...
                    settings.region_ids, ...
                    settings.assim.sdte, ...
                    settings.assim.edte, ...
                    settings.obscov.e_alt_errs.remsc, ...
                    settings.obscov.e_alt_errs.filter, ...
                    false);
                
            % Multiply the errors with a value from the settings-structure      
            E_errs = (E_in*settings.obscov.e_alt_errs.value).^2;          
    
            % Re-arrange the scaled values in diagonal matrices for each time-step
            for i = 1:settings.nts
                C_E_alt(:, :, i) = diag(E_errs(i, :));
            end
    
        elseif strcmp(settings.obscov.e_alt_errs.method, 'constant') 
            if length(settings.obscov.e_alt_errs.value) == 1
                E_errs = ones(length(settings.region_ids), 1) * ...
                                          settings.obscov.e_alt_errs.value;
            else
                E_errs = settings.obscov.e_alt_errs.value;
            end
    
            for i = 1:settings.nts
                C_E_alt(:, :, i) = diag(E_errs);
            end
            
        end
        
        C_big = [C_big [O; O; O; O]; ...
                 O O O O C_E_alt];
        
    else
        error('Must provide errors for E_alt')
    end   
end



if ~isempty(settings.obs.r_alt)
    if isfield(settings.obscov, 'r_alt_errs')
        if strcmp(settings.obscov.r_alt_errs.method, 'data')
            R_in = EnKF_Prepare_Data(settings.obscov.r_alt_errs.data, ...
                    [], ...
                    settings.obscov.r_alt_errs.varnme, ...
                    settings.id_var, ...
                    settings.region_ids, ...
                    settings.assim.sdte, ...
                    settings.assim.edte, ...
                    settings.obscov.r_alt_errs.remsc, ...
                    settings.obscov.r_alt_errs.filter, ...
                    false);
                            
            for i = 1:settings.nts
                C_R_alt(:, :, i) = diag(R_in(i, :));
            end  
        
        elseif strcmp(settings.obscov.r_alt_errs.method, 'percentage')
            % Load an ancillary time-series for deriving the percentage errors
            R_in = EnKF_Prepare_Data(settings.obscov.r_alt_errs.data, ...
                    [], ...
                    settings.obscov.r_alt_errs.varnme, ...
                    settings.id_var, ...
                    settings.region_ids, ...
                    settings.assim.sdte, ...
                    settings.assim.edte, ...
                    settings.obscov.r_alt_errs.remsc, ...
                    settings.obscov.r_alt_errs.filter, ...
                    false);
                
            % Multiply the errors with a value from the settings-structure      
            R_errs = (R_in*settings.obscov.r_alt_errs.value).^2;          
    
            % Re-arrange the scaled values in diagonal matrices for each time-step
            for i = 1:settings.nts
                C_R_alt(:, :, i) = diag(R_errs(i, :));
            end
    
        elseif strcmp(settings.obscov.r_alt_errs.method, 'constant') 
            if length(settings.obscov.r_alt_errs.value) == 1
                R_errs = ones(length(settings.region_ids), 1) * ...
                                          settings.obscov.r_alt_errs.value;
            else
                R_errs = settings.obscov.r_alt_errs.value;
            end
    
            for i = 1:settings.nts
                C_R_alt(:, :, i) = diag(R_errs);
            end
            
        end
        C_big = [C_big [O; O; O; O]; ...
                 O O O O C_R_alt];

        
    else
        error('Must provide errors for R_alt')
    end   
end




if ~isempty(settings.obs.dm_alt)
    if isfield(settings.obscov, 'dm_alt_errs')
        if strcmp(settings.obscov.dm_alt_errs.method, 'data')
            DM_in = EnKF_Prepare_Data(settings.obscov.dm_alt_errs.data, ...
                    [], ...
                    settings.obscov.dm_alt_errs.varnme, ...
                    settings.id_var, ...
                    settings.region_ids, ...
                    settings.assim.sdte, ...
                    settings.assim.edte, ...
                    settings.obscov.dm_alt_errs.remsc, ...
                    settings.obscov.dm_alt_errs.filter, ...
                    false);
                            
            for i = 1:settings.nts
                C_DM_alt(:, :, i) = diag(DM_in(i, :));
            end  
        
        elseif strcmp(settings.obscov.dm_alt_errs.method, 'percentage')
            % Load an ancillary time-series for deriving the percentage errors
            DM_in = EnKF_Prepare_Data(settings.obscov.dm_alt_errs.data, ...
                    [], ...
                    settings.obscov.dm_alt_errs.varnme, ...
                    settings.id_var, ...
                    settings.region_ids, ...
                    settings.assim.sdte, ...
                    settings.assim.edte, ...
                    settings.obscov.dm_alt_errs.remsc, ...
                    settings.obscov.dm_alt_errs.filter, ...
                    false);
                
            % Multiply the errors with a value from the settings-structure      
            DM_errs = (DM_in*settings.obscov.dm_alt_errs.value).^2;          
    
            % Re-arrange the scaled values in diagonal matrices for each time-step
            for i = 1:settings.nts
                C_DM_alt(:, :, i) = diag(DM_errs(i, :));
            end
    
        elseif strcmp(settings.obscov.dm_alt_errs.method, 'constant') 
            if length(settings.obscov.dm_alt_errs.value) == 1
                DM_errs = ones(length(settings.region_ids), 1) * ...
                                         settings.obscov.dm_alt_errs.value;
            else
                DM_errs = settings.obscov.dm_alt_errs.value;
            end
    
            for i = 1:settings.nts
                C_DM_alt(:, :, i) = diag(DM_errs);
            end
            
        end
        
        C_big = [C_big [O; O; O; O]; ...
                 O O O O C_DM_alt];
        
    else
        error('Must provide errors for DM_alt')
    end   
end




















    

        


